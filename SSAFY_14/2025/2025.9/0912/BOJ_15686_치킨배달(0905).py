# 백준 15686번 치킨 배달

# N×N인 도시
# 0 빈 칸, 2 치킨집, 1 집
# 도시의 칸은 (r, c)와 같은 형태 r행 c열 또는 위에서부터 r번째 칸, 왼쪽에서부터 c번째 칸을 의미 
# r과 c는 1부터 시작한다.

# 치킨 거리는 집과 가장 가까운 치킨집 사이의 거리
# 치킨 거리는 집을 기준으로 정해지며, 각각의 집은 치킨 거리를 가지고 있다. 
# 도시의 치킨 거리는 모든 집의 치킨 거리의 합
# 임의의 두 칸 (r1, c1)과 (r2, c2) 사이의 거리는 |r1-r2| + |c1-c2|

# 도시에 있는 치킨집 중에서 최대 M개를 고르고, 나머지 치킨집은 모두 폐업
# 도시의 치킨 거리가 가장 작게 될지 구하는 프로그램

# 반복을 통해서 치킨 집을 하나씩 다 볼건데
# 치킨 집 하나를 골라서, 모든 집과의 거리를 구해서 더해. 그리고 그걸 저장해둬
# 모든 치킨 집을 보고 난 뒤에 거리를 저장한 합을 작은 순서대로 정렬
# 앞에서부터 M개만큼 자른 다음 맨 앞의 값을 출력 -> 그러면 M개만큼 잘라야하는 이유가 있을까? 무조건 맨 앞이면 되지 않나

# --> 잘못된 접근) 각 치킨집 단독으로 도시의 치킨 거리를 계산해서, 
#                 그 거리의 합이 가장 작은 M개의 치킨집을 고르면, 도시 전체 치킨 거리도 최소가 될 것이다

# 이유) 도시의 치킨 거리는 각 집마다 가장 가까운 치킨집까지의 거리로 계산

# 오류 이름	부분 최적화로 전체 최적화를 시도한 오류
# 어떤 생각이었나?	단일 치킨집의 성능만 따져서 좋은 것들을 M개 고르면 최적일 것이다
# 왜 틀렸나?	집마다 가까운 치킨집이 다르고, 조합에 따라 치킨 거리가 달라지므로
# 어떤 전략이 필요했나?	M개의 치킨집 조합을 만들어서, 각 조합에 대해 도시 치킨 거리 계산 후 최소값 선택

# => 치킨 집을 조합으로 일단 만들어. 그리고 나서 치킨거리를 구해
# 그리고 최소값을 찾아서 출력


# 이건 방문체크 원복해야하는 것 같은데...
def dfs(start_r, start_c):
    global distance
    print(start_r,start_c)
    # 종료 조건이 뭘까...? 집을 모두 방문하면 종료하는거 아닌가
    for i in range(N):
        for j in range(N):
            if graph[i][j] == 1 and visited[i][j] == 0:
                distance += abs(start_r-i) + abs(start_c-j)
                visited[i][j] = 1
                dfs(start_r,start_c)
                # visited[i][j] = 0
    return distance
        


# N = 도시의 크기, M = 남길 치킨 집의 개수  
N, M = map(int, input().split())
graph = [list(map(int, input().split())) for _ in range(N)]
visited = [[0]*N for _ in range(N)] # 방문 체크

ans = []

for r in range(N):
    for c in range(N):
        # 치킨 집이고 방문하지 않은 치킨 집이면
        if graph[r][c] == 2 and visited[r][c] == 0:
            distance = 0
            ans.append(dfs(r,c))

print(ans)
