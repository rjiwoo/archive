<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>
        // 그러면 모든 곳에 async/await를 도배해야할까? 
        // 예시) 1초, 1.5초, 2초 걸리는 작업들을 다 처리한 후에 결과값을 출력해야 하는 경우
        function getBurger() {
            return new Promise(resolve => setTimeout(() => resolve("햄버거"), 1000));
        }
        function getFries() {
            return new Promise(resolve => setTimeout(() => resolve("감자튀김"), 1500));
        }
        function getCoke() {
            return new Promise(resolve => setTimeout(() => resolve("콜라"), 2000));
        }

        async function order() {
            console.time("주문 시간");

            const burger = await getBurger(); // 1초 대기
            const fries = await getFries();   // 1.5초 대기
            const coke = await getCoke();     // 2초 대기

            console.log(`${burger}, ${fries}, ${coke}`);
            console.timeEnd("주문 시간"); // 총 4.5초 이상 소요
        }

        // 함수 실행!
        // 워터폴 현상 발생!! => 서로 상관없는 작업들임에도 불구하고, 앞의 작업이 끝날 때까지 기다리는 비효율적인 현상
        order();


        // 해결 방법) Promise.all 활용
        // 순서를 고려하지 않고 호출해도 괜찮은 경우 사용 (함수 호출 순서가 중요하다면 await를 써야함)
        // 단점: 하나라도 실패하면 에러 발생 
        async function promiseAllOrder() {
            // 1. 주문을 전부 넣음 (Promise 객체 3개가 동시에 생성되면서 작업 시작)
            // await를 붙이지 않았으므로 멈추지 않고 변수에 'Promise 객체'가 담깁니다.
            const burgerPromise = getBurger();
            const friesPromise = getFries();
            const cokePromise = getCoke();

            // 2. Promise.all로 "이 3개가 다 끝날 때까지" 한 번만 기다림
            const [burger, fries, coke] = await Promise.all([getBurger(), getFries(), getCoke()]);

            console.log(result); // ["햄버거", "감자튀김", "콜라"]
            console.timeEnd("주문 시간"); // 약 2초 소요 (가장 오래 걸리는 작업 시간만큼만 걸림)
        }

        promiseAllOrder();

        ////////////////////////////
        // 알아두면 좋은 추가 Promise 메서드
        // 1. Promise.allSettled()
        const getCokeError = () => new Promise((_, reject) => setTimeout(() => reject(new Error("콜라 기계 고장")), 500));

        async function promiseSettledOrder() {
            const results = await Promise.allSettled([
                getBurger(), // 성공 (3초)
                getFries(),  // 성공 (1초)
                getCokeError()    // 실패 (0.5초)
            ]);

            /* status: pending(대기), fulfilled(성공), rejected(실패)
            [
                { status: 'fulfilled', value: '햄버거' },      // 성공
                { status: 'fulfilled', value: '감자튀김' },    // 성공
                { status: 'rejected', reason: Error: 콜라 기계 고장 } // 실패
            ]
            */
            console.log(results);

            // 성공한 음식만이라도 손님상에 내보내기
            const successMenu = results
                .filter(item => item.status === 'fulfilled') // 성공한 것만 필터링
                .map(item => item.value);

            console.log(`손님, 죄송하지만 콜라는 빼고 ${successMenu}만 준비했습니다.`);
        }

        promiseSettledOrder();

        ////////////////////////
        // 2. Promise.race()
        // 실제로는 주어진 시간안에 처리되지 않으면, 여러 다른 서버에 요청하는 용도로 사용

        // 2초 뒤에 무조건 에러
        const timeoutLimit = () => new Promise((_, reject) => {
            setTimeout(() => reject("주문 취소"), 2000);
        });

        async function promiseRaceOrder() {
            try {
                // 햄버거 (3초 걸림 - 느림)
                // 타임아웃 (2초 걸림 - 더 빠름)
                const winner = await Promise.race([
                    getBurger(), 
                    timeoutLimit()
                ]);
                
                // 햄버거가 2초보다 빨랐다면 여기가 실행되겠지만...
                console.log("받은 음식:", winner);

            } catch (error) {
                // 타임아웃(2초)이 햄버거(3초)보다 먼저 끝나서 '에러(reject)'
                console.log("결과:", error); // "시간 초과! 주문 취소"
            }
        }

        promiseRaceOrder();
    </script>
</body>
</html>