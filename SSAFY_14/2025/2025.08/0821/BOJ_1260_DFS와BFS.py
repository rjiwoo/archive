# 백준 1260번 DFS와 BFS

# 그래프를 DFS로 탐색한 결과와 BFS로 탐색한 결과를 출력하는 프로그램을 작성하시오. 
# 단, 방문할 수 있는 정점이 여러 개인 경우에는 정점 번호가 작은 것을 먼저 방문하고, 
# 더 이상 방문할 수 있는 점이 없는 경우 종료한다. 정점 번호는 1번부터 N번까지이다.

# 첫째 줄에 정점의 개수 N(1 ≤ N ≤ 1,000), 간선의 개수 M(1 ≤ M ≤ 10,000), 탐색을 시작할 정점의 번호 V가 주어진다. 
# 다음 M개의 줄에는 간선이 연결하는 두 정점의 번호가 주어진다. 
# 어떤 두 정점 사이에 여러 개의 간선이 있을 수 있다. 
# 입력으로 주어지는 간선은 양방향  => *** 무방향 그래프다 *****

# 정점의 개수 n, 간선의 개수 m, 탐색을 시작할 정점의 번호 v    
n, m, v=map(int, input().split())

# 노드가 어디로 이어져 있는지 표시하려는 인접행렬 (정점의 번호와 인덱스 번호를 맞추기 위해서 n+1)
# 0 이면 연결되지 않음
spots=[[0 for _ in range(n+1)] for _ in range(n+1)]

# 간선의 개수로 인접행렬에 표시
for _ in range(m):

    # 연결된 노드의 정보를 입력 받음
    a, b =map(int, input().split())

    # 입력으로 주어지는 간선은 양방향이라고 문제에서 제시
    # 무방향 그래프이기 때문에 동시에 표시
    spots[a][b] = spots[b][a] = 1 # a에서 b로 갈 수 있음, b에서 a로 갈 수 있음

# 방문 기록을 위한 리스트 생성
visited_dfs = []
visited_bfs = []


# DFS(깊이 우선 탐색) 함수 정의
# 재귀 호출 이용하여 구현
def dfs(start):

    # 현재 노드를 방문 기록에 추가
    visited_dfs.append(start)

    # 모든 노드를 확인하면서 연결된 다음 노드 탐색
    for i in range(1,n+1):

        # 현재 노드와 i번 노드와 연결되어 있는지
        # i번 노드는 방문한 적 없는 노드인지
        if spots[start][i]==1 and i not in visited_dfs:
            dfs(i) # 그 노드로 이동. (재귀 호출로 그 다음으로 탐색함)

    # 더 이상 갈 노드가 없으면, 최종 방문 기록을 반환함 
    # 하나의 탐색 가지가 끝날 때마다 실행됨. 이쪽 길은 탐색이 끝났으니 그 전 갈림길로 돌아가서 다른 길 찾아보자?       
    return visited_dfs


# BFS(넓이 우선 탐색) 함수 정의
# 큐 자료구조를 이용하여 구현
def bfs(start):

    # 현재 노드를 방문 기록과 큐에 추가
    visited_bfs.append(start)
    queue=[start]

    # 큐가 비어있을 때까지 (탐색할 노드가 없을 때까지) 반복
    while queue:

        # 큐에서 가장 먼저 들어온 노드를 꺼내기
        x = queue.pop(0)

        # 꺼낸 노드와 연결된 모든 다음 노드 찾기
        for i in range(1,n+1):

            # 현재 노드와 i번 노드가 연결되어 있는지?
            # i번 노드를 아직 방문하지 않았는지
            if spots[x][i]==1 and i not in visited_bfs:

                # 조건 만족하면, 해당 노드를 방문처리하고 큐에 추가
                visited_bfs.append(i)
                queue.append(i) # 나중에 탐색해야할 곳으로 큐에 저장하는 것
                                # 여기서 만약 바로 탐색하는 방법은 DFS임. 그래서 위에서 바로 재귀로 탐색하러 가는 것
                                # BFS는 넓이 우선 탐색이니까 지금 갈 수 있는걸 가보면서 그 다음에는 여기를 가야겠다고 저장하는 것

    # 모든 탐색이 끝나면, 최종 방문 기록을 반환            
    return visited_bfs

print(*dfs(v))
print(*bfs(v))